<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PLSearchCPP: pl_search Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PLSearchCPP<span id="projectnumber">&#160;1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pl_search Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1ChoiceIterator.html">ChoiceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for choice iterators.  <a href="classpl__search_1_1ChoiceIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1ChoicePred.html">ChoicePred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a choice predicate.  <a href="classpl__search_1_1ChoicePred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1CList.html">CList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a list of terms.  <a href="classpl__search_1_1CList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1Cut.html">Cut</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Prolog like cut. When called it pops env_stack thus removing choicepoints.  <a href="classpl__search_1_1Cut.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1DetPred.html">DetPred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a deterministic predicate.  <a href="classpl__search_1_1DetPred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1DisjPred.html">DisjPred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a disjunction of predicates.  <a href="classpl__search_1_1DisjPred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1Engine.html">Engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpl__search_1_1Engine.html" title="The Engine class manages the execution of predicates and backtracking.">Engine</a> class manages the execution of predicates and backtracking.  <a href="classpl__search_1_1Engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpl__search_1_1env__entry.html">env_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an environment entry for predicates.  <a href="structpl__search_1_1env__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1Loop.html">Loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a predicate that loops over (instances of) a predicate while some condition (loop_continues) is satisfied.  <a href="classpl__search_1_1Loop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1LoopBodyFactory.html">LoopBodyFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classpl__search_1_1LoopBodyFactory.html" title="LoopBodyFactory is an abstract base class used for generating instances of a predicate class used in ...">LoopBodyFactory</a> is an abstract base class used for generating instances of a predicate class used in the body of a loop.  <a href="classpl__search_1_1LoopBodyFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1NotNot.html">NotNot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an equivalent of the Prolog call \+\+Call. The aim is to determine if Call succeeds without binding any variables in the call.  <a href="classpl__search_1_1NotNot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1NotNotEnd.html">NotNotEnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intended for internal use by <a class="el" href="classpl__search_1_1NotNot.html" title="Represents an equivalent of the Prolog call \+\+Call. The aim is to determine if Call succeeds withou...">NotNot</a> which injects this call directly after the predicate supplied to the <a class="el" href="classpl__search_1_1NotNot.html" title="Represents an equivalent of the Prolog call \+\+Call. The aim is to determine if Call succeeds withou...">NotNot</a> constructor.  <a href="classpl__search_1_1NotNotEnd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1PAtom.html">PAtom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Prolog atom.  <a href="classpl__search_1_1PAtom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1PFloat.html">PFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Prolog float.  <a href="classpl__search_1_1PFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1PInt.html">PInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Prolog integer.  <a href="classpl__search_1_1PInt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1Pred.html">Pred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for Prolog-like predicates.  <a href="classpl__search_1_1Pred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1PVar.html">PVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Prolog variable.  <a href="classpl__search_1_1PVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1SemiDetPred.html">SemiDetPred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a semi-deterministic predicate.  <a href="classpl__search_1_1SemiDetPred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1Term.html">Term</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for terms that approximate Prolog terms.  <a href="classpl__search_1_1Term.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpl__search_1_1trail__entry.html">trail_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a trail entry for backtracking.  <a href="structpl__search_1_1trail__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1UpdatablePVar.html">UpdatablePVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UpdatableVar implements what some Prologs call updatable assignment.  <a href="classpl__search_1_1UpdatablePVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpl__search_1_1VarChoiceIterator.html">VarChoiceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choice iterator for variables.  <a href="classpl__search_1_1VarChoiceIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0e3a1e8ce6af631b512ff5b617da1b5a" id="r_a0e3a1e8ce6af631b512ff5b617da1b5a"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpl__search_1_1ChoiceIterator.html">ChoiceIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#a0e3a1e8ce6af631b512ff5b617da1b5a">ChoiceIteratorPtr</a></td></tr>
<tr class="separator:a0e3a1e8ce6af631b512ff5b617da1b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cbaf44aa4107d7b58c2ce227bf43e6" id="r_a97cbaf44aa4107d7b58c2ce227bf43e6"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpl__search_1_1Pred.html">Pred</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#a97cbaf44aa4107d7b58c2ce227bf43e6">PredPtr</a></td></tr>
<tr class="memdesc:a97cbaf44aa4107d7b58c2ce227bf43e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a shared pointer to a <a class="el" href="classpl__search_1_1Pred.html" title="Abstract base class for Prolog-like predicates.">Pred</a> object.  <br /></td></tr>
<tr class="separator:a97cbaf44aa4107d7b58c2ce227bf43e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefab13fe8a24c420b9a3b2792e5d0cb7" id="r_aefab13fe8a24c420b9a3b2792e5d0cb7"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpl__search_1_1Term.html">Term</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#aefab13fe8a24c420b9a3b2792e5d0cb7">TermPtr</a></td></tr>
<tr class="memdesc:aefab13fe8a24c420b9a3b2792e5d0cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedefs for shared pointers to Terms and subclasses.  <br /></td></tr>
<tr class="separator:aefab13fe8a24c420b9a3b2792e5d0cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc85f4a515edb54f6467c6cf0dbf8279" id="r_acc85f4a515edb54f6467c6cf0dbf8279"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpl__search_1_1PVar.html">PVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#acc85f4a515edb54f6467c6cf0dbf8279">PVarPtr</a></td></tr>
<tr class="separator:acc85f4a515edb54f6467c6cf0dbf8279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04f049c8373c0e2ded032e5a7841ac9" id="r_aa04f049c8373c0e2ded032e5a7841ac9"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpl__search_1_1PInt.html">PInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#aa04f049c8373c0e2ded032e5a7841ac9">PIntPtr</a></td></tr>
<tr class="separator:aa04f049c8373c0e2ded032e5a7841ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57c588f2d41c2bc02fdb8fb97e94f71" id="r_ac57c588f2d41c2bc02fdb8fb97e94f71"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpl__search_1_1PFloat.html">PFloat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#ac57c588f2d41c2bc02fdb8fb97e94f71">PFloatPtr</a></td></tr>
<tr class="separator:ac57c588f2d41c2bc02fdb8fb97e94f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab012d6cd0f04b52664a75411cbf240b0" id="r_ab012d6cd0f04b52664a75411cbf240b0"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpl__search_1_1PAtom.html">PAtom</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#ab012d6cd0f04b52664a75411cbf240b0">PAtomPtr</a></td></tr>
<tr class="separator:ab012d6cd0f04b52664a75411cbf240b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3671086e7ecd34b431d841ad4e4b91" id="r_a5f3671086e7ecd34b431d841ad4e4b91"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpl__search_1_1CList.html">CList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#a5f3671086e7ecd34b431d841ad4e4b91">CListPtr</a></td></tr>
<tr class="separator:a5f3671086e7ecd34b431d841ad4e4b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e5c92084fca8501e48764f8724566f" id="r_ad2e5c92084fca8501e48764f8724566f"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpl__search_1_1UpdatablePVar.html">UpdatablePVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#ad2e5c92084fca8501e48764f8724566f">UpdatablePVarPtr</a></td></tr>
<tr class="separator:ad2e5c92084fca8501e48764f8724566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab463f6f2fee72cb6ee931c291c560e1f" id="r_ab463f6f2fee72cb6ee931c291c560e1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepl__search.html#a97cbaf44aa4107d7b58c2ce227bf43e6">PredPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#ab463f6f2fee72cb6ee931c291c560e1f">conjunction</a> (std::vector&lt; <a class="el" href="namespacepl__search.html#a97cbaf44aa4107d7b58c2ce227bf43e6">PredPtr</a> &gt; preds)</td></tr>
<tr class="memdesc:ab463f6f2fee72cb6ee931c291c560e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a conjunction of predicates by chaining them together via continuations.  <br /></td></tr>
<tr class="separator:ab463f6f2fee72cb6ee931c291c560e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8358cb5b08101f69c2e56f17a15a6f" id="r_a7c8358cb5b08101f69c2e56f17a15a6f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#a7c8358cb5b08101f69c2e56f17a15a6f">repr</a> (<a class="el" href="namespacepl__search.html#a97cbaf44aa4107d7b58c2ce227bf43e6">PredPtr</a> pred)</td></tr>
<tr class="separator:a7c8358cb5b08101f69c2e56f17a15a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e166c78a77348891e80f1aea50d5e0d" id="r_a9e166c78a77348891e80f1aea50d5e0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#a9e166c78a77348891e80f1aea50d5e0d">operator==</a> (<a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;t1, <a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;t2)</td></tr>
<tr class="memdesc:a9e166c78a77348891e80f1aea50d5e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">== test for TermPtrs  <br /></td></tr>
<tr class="separator:a9e166c78a77348891e80f1aea50d5e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da3e86b01c1df74455648c4bbbeb82c" id="r_a0da3e86b01c1df74455648c4bbbeb82c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#a0da3e86b01c1df74455648c4bbbeb82c">operator&lt;</a> (<a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;t1, <a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;t2)</td></tr>
<tr class="memdesc:a0da3e86b01c1df74455648c4bbbeb82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; operator for Terms. Approximates the &lt; operator in Prolog. The ordering is as follows: pvar &lt; pint, pfloat &lt; patom &lt; clist &lt; user-defined classes "older" vars are less than "newer" vars patoms are ordered by name pints and pfloats are ordered by value clists are ordered by the first element, then the second, etc.  <br /></td></tr>
<tr class="separator:a0da3e86b01c1df74455648c4bbbeb82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceac28fa492b3c00f8fcc08c0775d43f" id="r_aceac28fa492b3c00f8fcc08c0775d43f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepl__search.html#aceac28fa492b3c00f8fcc08c0775d43f">operator&lt;=</a> (<a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;t1, <a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;t2)</td></tr>
<tr class="memdesc:aceac28fa492b3c00f8fcc08c0775d43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;= operator for Terms  <br /></td></tr>
<tr class="separator:aceac28fa492b3c00f8fcc08c0775d43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0e3a1e8ce6af631b512ff5b617da1b5a" name="a0e3a1e8ce6af631b512ff5b617da1b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3a1e8ce6af631b512ff5b617da1b5a">&#9670;&#160;</a></span>ChoiceIteratorPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpl__search_1_1ChoiceIterator.html">ChoiceIterator</a>&gt; <a class="el" href="namespacepl__search.html#a0e3a1e8ce6af631b512ff5b617da1b5a">pl_search::ChoiceIteratorPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f3671086e7ecd34b431d841ad4e4b91" name="a5f3671086e7ecd34b431d841ad4e4b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3671086e7ecd34b431d841ad4e4b91">&#9670;&#160;</a></span>CListPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpl__search_1_1CList.html">CList</a>&gt; <a class="el" href="namespacepl__search.html#a5f3671086e7ecd34b431d841ad4e4b91">pl_search::CListPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab012d6cd0f04b52664a75411cbf240b0" name="ab012d6cd0f04b52664a75411cbf240b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab012d6cd0f04b52664a75411cbf240b0">&#9670;&#160;</a></span>PAtomPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpl__search_1_1PAtom.html">PAtom</a>&gt; <a class="el" href="namespacepl__search.html#ab012d6cd0f04b52664a75411cbf240b0">pl_search::PAtomPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac57c588f2d41c2bc02fdb8fb97e94f71" name="ac57c588f2d41c2bc02fdb8fb97e94f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57c588f2d41c2bc02fdb8fb97e94f71">&#9670;&#160;</a></span>PFloatPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpl__search_1_1PFloat.html">PFloat</a>&gt; <a class="el" href="namespacepl__search.html#ac57c588f2d41c2bc02fdb8fb97e94f71">pl_search::PFloatPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa04f049c8373c0e2ded032e5a7841ac9" name="aa04f049c8373c0e2ded032e5a7841ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04f049c8373c0e2ded032e5a7841ac9">&#9670;&#160;</a></span>PIntPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpl__search_1_1PInt.html">PInt</a>&gt; <a class="el" href="namespacepl__search.html#aa04f049c8373c0e2ded032e5a7841ac9">pl_search::PIntPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97cbaf44aa4107d7b58c2ce227bf43e6" name="a97cbaf44aa4107d7b58c2ce227bf43e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cbaf44aa4107d7b58c2ce227bf43e6">&#9670;&#160;</a></span>PredPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpl__search_1_1Pred.html">Pred</a>&gt; <a class="el" href="namespacepl__search.html#a97cbaf44aa4107d7b58c2ce227bf43e6">pl_search::PredPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a shared pointer to a <a class="el" href="classpl__search_1_1Pred.html" title="Abstract base class for Prolog-like predicates.">Pred</a> object. </p>

</div>
</div>
<a id="acc85f4a515edb54f6467c6cf0dbf8279" name="acc85f4a515edb54f6467c6cf0dbf8279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc85f4a515edb54f6467c6cf0dbf8279">&#9670;&#160;</a></span>PVarPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpl__search_1_1PVar.html">PVar</a>&gt; <a class="el" href="namespacepl__search.html#acc85f4a515edb54f6467c6cf0dbf8279">pl_search::PVarPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefab13fe8a24c420b9a3b2792e5d0cb7" name="aefab13fe8a24c420b9a3b2792e5d0cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefab13fe8a24c420b9a3b2792e5d0cb7">&#9670;&#160;</a></span>TermPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpl__search_1_1Term.html">Term</a>&gt; <a class="el" href="namespacepl__search.html#aefab13fe8a24c420b9a3b2792e5d0cb7">pl_search::TermPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedefs for shared pointers to Terms and subclasses. </p>

</div>
</div>
<a id="ad2e5c92084fca8501e48764f8724566f" name="ad2e5c92084fca8501e48764f8724566f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e5c92084fca8501e48764f8724566f">&#9670;&#160;</a></span>UpdatablePVarPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpl__search_1_1UpdatablePVar.html">UpdatablePVar</a>&gt; <a class="el" href="namespacepl__search.html#ad2e5c92084fca8501e48764f8724566f">pl_search::UpdatablePVarPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab463f6f2fee72cb6ee931c291c560e1f" name="ab463f6f2fee72cb6ee931c291c560e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab463f6f2fee72cb6ee931c291c560e1f">&#9670;&#160;</a></span>conjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepl__search.html#a97cbaf44aa4107d7b58c2ce227bf43e6">PredPtr</a> pl_search::conjunction </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacepl__search.html#a97cbaf44aa4107d7b58c2ce227bf43e6">PredPtr</a> &gt;&#160;</td>
          <td class="paramname"><em>preds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a conjunction of predicates by chaining them together via continuations. </p>
<p>Creates a conjunction of predicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preds</td><td>A vector of shared pointers to the predicates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the first predicate in the conjunction. </dd></dl>

</div>
</div>
<a id="a0da3e86b01c1df74455648c4bbbeb82c" name="a0da3e86b01c1df74455648c4bbbeb82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da3e86b01c1df74455648c4bbbeb82c">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pl_search::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; operator for Terms. Approximates the &lt; operator in Prolog. The ordering is as follows: pvar &lt; pint, pfloat &lt; patom &lt; clist &lt; user-defined classes "older" vars are less than "newer" vars patoms are ordered by name pints and pfloats are ordered by value clists are ordered by the first element, then the second, etc. </p>
<p>&lt; operator for Terms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>The first term. </td></tr>
    <tr><td class="paramname">t2</td><td>The second term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first term is less than the second term, false otherwise. </dd></dl>

</div>
</div>
<a id="aceac28fa492b3c00f8fcc08c0775d43f" name="aceac28fa492b3c00f8fcc08c0775d43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceac28fa492b3c00f8fcc08c0775d43f">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pl_search::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt;= operator for Terms </p>
<p>&lt;= operator for <a class="el" href="classpl__search_1_1Term.html" title="Abstract base class for terms that approximate Prolog terms.">Term</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>The first term. </td></tr>
    <tr><td class="paramname">t2</td><td>The second term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first term is less than or equal to the second term, false otherwise. </dd></dl>

</div>
</div>
<a id="a9e166c78a77348891e80f1aea50d5e0d" name="a9e166c78a77348891e80f1aea50d5e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e166c78a77348891e80f1aea50d5e0d">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pl_search::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpl__search_1_1Term.html">Term</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>== test for TermPtrs </p>
<p>== operator for Terms</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>The first term. </td></tr>
    <tr><td class="paramname">t2</td><td>The second term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the terms are equal using the isEqualTo method, false otherwise. </dd></dl>

</div>
</div>
<a id="a7c8358cb5b08101f69c2e56f17a15a6f" name="a7c8358cb5b08101f69c2e56f17a15a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8358cb5b08101f69c2e56f17a15a6f">&#9670;&#160;</a></span>repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pl_search::repr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepl__search.html#a97cbaf44aa4107d7b58c2ce227bf43e6">PredPtr</a>&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
